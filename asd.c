#include <stdio.h> 
#include <ctype.h>
#include <inttypes.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>

// NECESARA PENTRU FUNCTIA _delay_ms(10);
#include <util/delay.h>

// DEFINIRE PORTURILOR UTILIZATE PENTRU IMPLEMENTAREA ADC-LUI
#define  ADC_H  PORTC
#define  ADC_L  PORTB

#define WAIT_SH  _delay_us(500)

// DEFINIREA RUTINELOR PENTRU COMUNICATIA SERIALA ASINCRONA
// 'uart1_putchar' -> TRANSMISIE DATE DE PE INTERFATA USART
// 'uart1_getchar' <- RECEPTIE DATE DE PE INTERFATA USART
static int uart1_putchar(char c);
static int uart1_getchar(void);



// DEFINIREA DESCRIPTORUL ATASAT FLUXURILOR STANDARD DE COMUNICATIE
// INTERCONECTAREA FLUXURILOR STANDARD DE COMUNICATIE LA RUTINELE 
// CARE IMPLEMENTEAZA / GESTIONEAZA COMUNICATIA SERIALA ASINCRONA 
// CELE TREI CONEXIUNI DE INTRARE / IESIRE (I / O) SE NUMESC:
//  - INTRARE STANDARD ( STDIN )
//  - IESIRE  STANDARD ( STDOUT ) 
//  - EROARE  STANDARD ( STDERR ) 
static FILE strm_uart1 = FDEV_SETUP_STREAM(uart1_putchar, uart1_getchar, _FDEV_SETUP_RW);


// DESCRIEREA FUNCTIONALITATII ADC-LUI DE TIPUL SAR (SUCCESSIVE-APPROXIMATION REGISTER )
// IMPLEMENTAT CU AJUTORUL UNEI RETELE REZISTIVE DE TIPUL R-2R
unsigned int ADC_SAR_R_2R()
{

      unsigned int RET_ADC_VAL=0x00000;

      ADC_H = 0b00000000;
      ADC_L = 0b00000000;
 
       ADC_H |= 0b10000000;
      WAIT_SH ;
      ADC_H  = ( ACSR  & 0b00100000) ? ADC_H  & 0b01111111: ADC_H  | 0b10000000 ;

      ADC_H  |= 0b01000000;
      WAIT_SH ;
      ADC_H  = ( ACSR  & 0b00100000) ? ADC_H  & 0b10111111: ADC_H  | 0b01000000 ;

      ADC_H  |= 0b00100000;
      WAIT_SH ;
      ADC_H  = ( ACSR  & 0b00100000) ? ADC_H  & 0b11011111: ADC_H  | 0b00100000 ;

      ADC_H  |= 0b00010000;
      WAIT_SH ;
      ADC_H  = ( ACSR  & 0b00100000) ? ADC_H  & 0b11101111: ADC_H  | 0b00010000 ;

      ADC_H  |= 0b00001000;
      WAIT_SH ;
      ADC_H  = ( ACSR  & 0b00100000) ? ADC_H  & 0b11110111: ADC_H  | 0b00001000 ;

      ADC_H  |= 0b00000100;
      WAIT_SH ;
      ADC_H  = ( ACSR  & 0b00100000) ? ADC_H  & 0b11111011: ADC_H  | 0b00000100 ;

      ADC_H  |= 0b00000010;
      WAIT_SH ;
      ADC_H  = ( ACSR  & 0b00100000) ? ADC_H  & 0b11111101: ADC_H  | 0b00000010 ;

      ADC_H  |= 0b00000001;
      WAIT_SH ;
      ADC_H   = ( ACSR  & 0b00100000) ? ADC_H  & 0b11111110 : ADC_H  | 0b00000001 ;



      ADC_L = 0b10000000;
      WAIT_SH ;
      ADC_L  = ( ACSR  & 0b00100000) ? ADC_L  & 0b01111111: ADC_L  | 0b10000000 ;

      ADC_L  |= 0b01000000;
      WAIT_SH ;
      ADC_L  = ( ACSR  & 0b00100000) ? ADC_L  & 0b10111111: ADC_L  | 0b01000000 ;

      ADC_L  |= 0b00100000;
      WAIT_SH ;
      ADC_L  = ( ACSR  & 0b00100000) ? ADC_L  & 0b11011111: ADC_L  | 0b00100000 ;

      ADC_L  |= 0b00010000;
      WAIT_SH ;
      ADC_L  = ( ACSR  & 0b00100000) ? ADC_L  & 0b11101111: ADC_L  | 0b00010000 ;

      ADC_L  |= 0b00001000;
      WAIT_SH ;
      ADC_L  = ( ACSR  & 0b00100000) ? ADC_L  & 0b11110111: ADC_L  | 0b00001000 ;

      ADC_L  |= 0b00000100;
      WAIT_SH ;
      ADC_L  = ( ACSR  & 0b00100000) ? ADC_L  & 0b11111011: ADC_L  | 0b00000100 ;

      ADC_L  |= 0b00000010;
      WAIT_SH ;
      ADC_L  = ( ACSR  & 0b00100000) ? ADC_L  & 0b11111101: ADC_L  | 0b00000010 ;

      ADC_L  |= 0b00000001;
      WAIT_SH ;
      ADC_L   = ( ACSR  & 0b00100000) ? ADC_L  & 0b11111110 : ADC_L  | 0b00000001 ;

      RET_ADC_VAL = ADC_H * 256 + ADC_L;

   return RET_ADC_VAL;  
}


// BAUD RATE:4800 (BIT U2X=0, FOSC=1.00MHZ, REG.: UBRR1L, TABEL: 82)
// FORMULA DE CALCUL A BAUD RATE-LUI (TABEL: 74)
// DIMENSIUNE PACHET DATA: 8 BIT (TABEL: 80)
// COMUNICATIE SERIALA ASINCRONA: (REG.: UCSR1C  TABEL: 77)
// FARA PARITATE (REG.: UCSR1C  TABEL: 78)
// 1 BIT STOP: (REG.: UCSR1C  TABEL: 79)
// CONTROL TRASFER DATE: FARA CONTROL (SW/HW)
void uart1_init(void)
{
 UCSR1B = 0x00; //disable while setting baud rate
 UCSR1A = 0x00;
 UCSR1C = 0x06;
 UBRR1L = 0x0C; //set baud rate lo
 UBRR1H = 0x00; //set baud rate hi
 UCSR1B = 0x18;
}

// TRANSMISIA BYTE-LUI (CARACTER-LUI) PE SERIALA SE VA REALIZA DUPA CE IN PREALABIL
// S-A TESTAT CA SERIALA ESTE DISPONIBILA PENTRU A REALIZA ACEST LUCRU (METODA POOLING)
// IN CAZ CONTRAR SE VA ASTEPTA PANA CAND ACEASTA INTERFATA DEVINE DISPONIBILA (VEZI PG. 177)
static int uart1_putchar(char c)
{
  if(c == '\n') 
    uart1_putchar('\r');

  while ((UCSR1A & 0x20) == 0);   // UDRE, data register empty
    UDR1 = c;

  return 0;
}

static int uart1_getchar(void)
{
}

  // TEMA 2 - CONFIGURATI URMATORII REGISTRII DIN RUTINA ADC_SAR_R_2R_init ASTFEL INCAT:
  // - PORTURILE  PORTC (ADC_H), PORTB (ADC_L) SA PERMITA COMANDA RETELEI R-2R
  // - ACTIVAREA MODULULUI COMPARATOR (VEZI ATMEGA128_ANALOG_COMPARATOR.pdf)


  // INITIALIZAREA MODULULUI COMPARATOR ANALOGIC
void ADC_SAR_R_2R_init(void)
{
   DDRB = 0xFF;  //
   DDRC = 0xFF;  //
   ACSR = 0b00000000;  // CONFIGURARE COMPARATOR ANALOGIC
}

int main()
 { 
  unsigned int uADC=0;
  float  fADC=0.0;
  unsigned int  TIME_STAMP = 0;

   // DEZACTIVAREA TUTUROR INTRERUPERILOR PENTRU PROGRAMAREA INTERFETELOR 
   // ( ARE ROLUL DE A PREVINE PROGRAMAREA DEFECTUOASA SAU PARTIALA A MODULELOR / INTERFETELOR )
   // SE REALIZEAZA PRIN SETAREA IN 0 A BITULUI 7 IN CADRUL REGISTRULUI SREG 
   // A BITUL 7 DIN SREG ESTE RESPONSABIL CU ACTIVAREA / DEZACTIVAREA GLOBALA A INTRERUPERILOR
   cli();

   // INITIALIZAREA MODULULUI COMPARATOR ANALOGIC
   ADC_SAR_R_2R_init();

   // INITIALIZAREA INTERFETEI SERIALE ASINCRONE USART1
   uart1_init();

   // ASIGNAREA PRIN REFERINTA A DESCRIPTORUL ATASAT LA FLUXURILE STANDARD DE COMUNICATIE
   // 
   // ACCESAREA FLUXURILOR DE IESIRE  STANDARD ( STDOUT ) SAU EROARE  STANDARD ( STDERR )
   // VA DETRMINA APELAREA RUTINEI 'uart1_putchar' (DE EX. putchar(), puts(), printf())
   //
   // ACCESAREA FLUXULUI DE INTRARE  STANDARD ( STDIN )
   // VA DETRMINA APELAREA RUTINEI 'uart1_getchar' (DE EX. getchar(), gets(), scanf())
   stdout = stdin = stderr = &strm_uart1;

   // ACTIVAREA TUTUROR INTRERUPERILOR (SETAREA IN 1 IN CADRUL REGISTRULUI SREG 
   // A BITULUI RESPONSABIL CU ACTIVAREA / DEZACTIVAREA GLOBALA A INTRERUPERILOR 
   sei();

   
   printf("\nCONVERTOR ANALOG NUMERIC \n - METODA: APROXIMARI SUCCESIVE \n - RETEA: R-2R\n\n");

   while (1)
      {

      // TEMA 3 
      //   - ANALIZATI  PRINCIPIUL DE FUNCTIONARE AL UNUI CONVERTOR ANALOG NUMERIC DE TIPUL APROXIMARI SUCCESIVE,  CU RETEA R - 2R 
      //  - ANALIIZATI RUTINA ADC_SAR_R_2R()
      //  - OPTIMIZATI RUTINA ADC_SAR_R_2R() 
  
      // PRELUAREA VALORII FURNIZATE DE CATRE CONVERTORUL ANALOG NUMERIC DE TIPUL APROXIMARI SUCCESIVE,  CU RETEA R - 2R 
      uADC = ADC_SAR_R_2R();
      
      // CONVERSIA DE LA VALOARE  FURNIZATA DE CATRE ADC [0..65535] - LA VALOAREA NUMERICA DE TIPUL FORMAT TENSIUNE [0.00V - 5.00V]
      fADC = (float) uADC * 5.0 /  65535.0;
      printf("\n[%06i]: 0x%04X, %1.3fV ",  TIME_STAMP, uADC, fADC );

      // CONTOR OPERATIE CURENTA 
      TIME_STAMP++;
      _delay_ms(500);

      }
   return 0;
 }